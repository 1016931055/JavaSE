并发编程：多线程

- Java语言中线程，提供了类：Thread

  - 线程相关功能（角色1）
  - 书写线程任务（角色2）

- 多线程程序的使用：

  - Thread类

  ~~~java
  //子类继承了Thread类后，无法在继承其他父类
  public class 子类 extends Thread{ 
      //重写run方法 （线程任务）
      public void run(){
          //线程要完成的任务代码
      }
  }
  //在线程类中，把线程功能和线程任务关联在一起了（程序的耦合度高）
  //建议：把线程功能和线程任务拆分
  
  线程子类  对象 = new 线程子类();
  对象.start();//开启新线程并执行run方法
  ~~~

  - Runnable接口 

  ~~~java
  //子类在实现Runnable接口后，还可以继承其他父类，还可以继续实现其他接口
  public class 子类 implements Runnable{
      //重写run方法（线程任务）
      public void run(){
          //线程要完成的任务代码
      }
  }
  //Runnable接口中，只有线程任务 
  //Runnable需要依赖Thread类才可以执行
  
  子类  线程任务对象 = new 子类();
  new Thread( 线程任务对象 ).start();//开启新线程，并执行线程任务对象中的run方法
  ~~~

- 线程安全问题

  - 出现安全问题的原因：多个线程对同一个数据进行读写操作，造成数据错乱

  - 解决方案：同步机制

    1. 同步代码块
    2. 同步方法
    3. Lock锁

  - 同步代码块：

    ~~~java
    对象锁可以任意类型
        
    //确保：多个线程使用同一个对象锁
    synchronized(对象锁)
    {
        //多个线程操作共享数据的代码
    }
    ~~~

  - 同步方法：

    ~~~java
    //同步方法也有对象锁，只是不需要程序员手动指定（非静态方法，默认：this锁）
    public synchronized 返回值类型 方法名(参数列表){
        //多个线程操作共享数据的代码
    }
    ~~~

  - Lock锁：

    ~~~java
    //创建Lock对象
    Lock l = new ReentrantLock();
    
    public void run(){
        //线程任务代码
        
        l.lock();//获取锁
        
        //多个线程操作共享数据的代码
        
        l.unlock();//释放锁
    }
    ~~~

- 线程的六种状态

  1. 新建状态

     ~~~java
     Thread t = new Thread();
     ~~~

  2. 就绪状态

     ~~~java
     t.start();
     ~~~

  3. 阻塞状态

     ~~~java
     没有获取到锁对象
     ~~~

  4. 等待状态

     ~~~java
     wait();
     ~~~

  5. 计时等待状态

     ~~~java
     sleep(100);
     wait(1000);
     ~~~

  6. 死亡状态







## 线程通讯

什么线程通讯？

- 在多线程程序中，某个线程进入到"等待状态"时，必须有其他线程来唤醒处于"等待状态"的线程

线程通讯需要使用的API方法：

- 等待方法

  - 特殊之处：会释放掉对象锁

  ~~~java
  wait() //无限等待 （只能其他线程唤醒）
  wait(long 毫秒) //计时等待 （时间到了自动唤醒）    
  ~~~

- 唤醒方法

  - 特殊之处：不会释放掉对象锁

  ~~~java
  notify()  //唤醒处于"等待状态"的任意一个线程
  nitityAll() //唤醒处于"等待状态"的所有线程   
  ~~~

使用细节：

- wait()方法和notify()方法 ，都必须绑定在对象锁上

  ~~~java
  Object lock = new Object(); //对象锁
  
  lock.wait();
  
  lock.notify();
  ~~~





线程创建的四种方式：

1. Thread
2. Runnable
3. 线程池
4. Callable

















封装类

~~~java
public class User{
    //姓名 
    private String name;
    
    //注册日期
    private Date registerDate;
    
    //头像
    private File file;  //上传文件
}
~~~







## File类

什么是File类？

- java.io.File类是java语言提供了用来描述 磁盘文件 和磁盘目录 的

File类怎么使用？

~~~java
public File(String path)
    
//文件对象
    File  file = new File("F:\上海黑马JavaEE153期\JavaSE进阶_day10\01_课件\小记.txt");
    
//目录对象
    File  dir = new File("F:\上海黑马JavaEE153期\JavaSE进阶_day10\01_课件");
~~~

~~~java
public File(String parent , String child)//基于父路径 和子路径 合并 后，生成File对象
    
//文件对象
    File  file = new File("F:\上海黑马JavaEE153期\JavaSE进阶_day10\01_课件","小记.txt");
    
//目录对象
    File  dir = new File("F:\上海黑马JavaEE153期" , "JavaSE进阶_day10\01_课件");    
~~~





绝对路径和相对路径

- 绝对路径：带盘符的路径（完整路径）

- 相对路径：拿一个目录作为参照，以参数目录进行路径书写

  



File类 ： 文件、目录 

- 文件：创建、删除
- 目录：创建、删除
- 判断：是文件、是目录 、文件或目录是否存在









回顾上午内容：

- File类

  - 用来描述计算机磁盘上的文件或目录的

- File类构造方法

  ~~~java
  File file = new File("绝对路径");
  File file = new File("父路径" , "子路径");
  
  
  File f = new File("f:/files/hello.txt");//绝对路径
  File f = new File("itheima/HelloWorld.java");//相对当前项目工程来讲
  ~~~

- File类常用功能：

  - 创建文件|目录

    ~~~java 
    //创建新文件
    File f = new File("f:/files/hello.txt");
    f.createNewFile();
    
    //创建新目录
    File f = new File("itheima/itcast/javaee153");
    f.mkdirs();
    ~~~









## IO流



IO流解决程序中的什么问题？

- 把程序中存储在内存中的数据，写入到文件中（持久存储）
- 把磁盘文件中存储的数据，读取到内存中



IO流：

- I流： 把磁盘文件中存储的数据，读取到内存中（读数据）
- O流：把内存中的数据，写入到磁盘文件（写数据）



InputStream：输入流

- 字节输入流
- 字符输入流

OutputStream：输出流

- 字节输出流
- 字符输出流



字节流：万能流（所有类型的文件都可以读写）

字符流：通常用于针对纯文本文件进行读写操作

- 纯文本文件： 使用计算机中的记事本软件打开并看得懂的文件



File类，只能针对文件本身进行创建、删除（无法对文件中存储的内容进行操作的）

使用IO流，对文件中存储的内容进行操作（读、写）



IO流中的基础流：

- 字节流
- 字符流





IO流的作用：对磁盘上的文件进行读、写操作

- 读：输入流
- 写：输出流（把内存中的数据写入到磁盘文件中）





### 字节输出流

字节输出流：以字节为单位，把内存中数据写入到磁盘文件中



学习所有的IO流有一个固定套路：

- 第1步：创建
  - 实例化不同的IO流类
- 第2步：操作(写、读)
  - 读：read()
  - 写：write()
- 第3步：关闭
  - close()



向文件中追加写入数据：（创建字节输出流对象时，不会清空文件中的原有内容）

~~~java
FileOutputStream fos = new FileOutputStream("关联文件" , true );
//第二个参数： true ， 表示追加写入数据
~~~

向文件中写入：换行符号

~~~java
fos.write("\r\n".getBytes());
~~~









字节输出流：OutputStream（父类、抽象类）

- 子类：FileOutputStream

字节输入流：InputStream（父类 、 抽象类）

- 子类：FileInputStream



### 字节输入流

InputStream（抽象类）

- FileInputStream类

~~~java

~~~







文件复制方案：

- 前置：
  - 有源文件（读源文件中的数据）
  - 有目标文件（向目标文件中写入数据）

1. 创建字节输入流，关联源文件
2. 创建字节输出流，关联目标文件
3. 使用字节输入流，读取源文件中的字节数据
4. 把读取到的字节数据，写入到目标文件中
5. 循环重复：3、4
6. 当源文件读取结束（ 结束标记：-1 ）
7. 释放资源





try..catch升级版：

~~~java
try{
    
    //监视可能会发生异常的代码
    
}catch(Exception e){
    
    //处理异常
    
}finally{
    
    //不论是否有异常，都会执行
    //应用场景： 释放资源
    
}
~~~

JDK1.7版本中IO资源处理代码：

- 好处：自动释放IO资源  （ 不需要在书写close方法 ）
  - 资源对象想要实现自动释放，必须保证资源对象有实现AutoCloseable接口

~~~java
try( IO流对象; IO流对象; ... ){
    
    //监视可能会发生异常的代码
    
}catch(Exception e){
    
    //处理异常
    
}
~~~









